---
title: "텐서플로우 베이직"
excerpt: "텐서플로우의 기본적인 모델 작성법"

categories:
  - 딥러닝
tags:
  - Deep Learning
  - Machine Learning
  - Data Science

toc: true
toc_sticky: true

---

## Tensorflow 모델 작성법

1. Sequential
2. Functional
3. Model Subclassing
<br/>

### Sequential 사용법
```python
import tensorflow as tf

# build a model type 1
model = tf.keras.Sequntial()
model.add(tf.keras.layers.__layer-name__(__params__))
model.add(tf.keras.layers.__layer-name__(__params__))
model.add(tf.keras.layers.__layer-name__(__params__))

# build a model type 2
model = tf.keras.Sequential([
	tf.keras.layers.__layer-name__(__params__),
	tf.keras.layers.__layer-name__(__params__),
	tf.keras.layers.__layer-name__(__params__)
])

# compile model
model.compile(__params__)

# adjust model
model.fit(x, y, epochs=10, batch_size=32)
```
Sequential 모델은 하나의 입력 - 하나의 출력을 전제로 합니다.
<br/>

### Functional 사용법
```python
import tensorflow as tf

# params
inputs = tf.keras.Input(shape = (__input-shape__))
x = tf.keras.layers.__layer-name__(__params__)(input)
x = tf.keras.layers.__layer-name__(__params__)(x)
outputs = tf.keras.layers.__layer-name__(__params__)(x)

# build a model
model = tf.keras.Model(inputs = inputs, outputs = outputs)

# compile model
model.compile(__params__)

# adjust model
model.fit(x, y, epochs = 10, batch_size = 32)
```
Functional 모델은 input과 output을 정의하여 생성합니다.
다중 입출력이 가능합니다.
<br/>

### Subclassing 사용법
```python
import tensorflow as tf

class MyModel(tf.keras.Model):
	def __init__(self):
		super(MyModel, self).__init__()
		self.__mylayer__ = tf.keras.layers.__layer-name__(__params__)
		self.__mylayer__ = tf.keras.layers.__layer-name__(__params__)
		self.__mylayer__ = tf.keras.layers.__layer-name__(__params__)

	def call(self, x):
		x = self.__mylayer__(x)
		x = self.__mylayer__(x)
		x = self.__mylayer__(x)

		return x

model = MyModel()

model.compile(__params__)

model.fit(x, y, epochs = 10, batch_size = 32)
```

## 실습 1. MNIST

MNIST 데이터는 숫자 손글씨 이미지와 0부터 9까지의 숫자로 이루어져 있습니다.<br/>
이미지를 받아서 0부터 9까지의 숫자 중 하나로 분류하는 모델을 만들어보겠습니다.<br/>
[Tensorflow, Datasets, MNIST](https://www.tensorflow.org/datasets/catalog/mnist)

**요구사항**
- Data
  - 데이터 로드
  - 데이터 정규화 (0~255 → 0~1)
  - 데이터 차원 확장 (newaxis)
- Model
  1. 필터가 32개, 커널 사이즈가 3이며 relu를 사용하는 Conv2D 레이어
  2. 필터가 64개, 커널 사이즈가 3이며 relu를 사용하는 Conv2D 레이어
  3. 1차원 변환
  4. 출력 노드가 128개이며 relu를 사용하는 fully-connected 레이어
  5. 출력값이 10개(0부터 9까지의 숫자)이며 softmax를 사용하는 fully-connected 레이어
- Train
  - 모델 컴파일
  - 모델 피팅
  - 모델 평가

Conv2D 레이어의 필터는 커널 채널의 개수를 말합니다.
커널의 사이즈란 커널 채널의 크기를 말합니다.

필터가 32개, 커널 사이즈가 3인 Conv2D 레이어란 아래 이미지와 같은 3x3 크기의 커널 채널을 32개 만들겠다는 의미입니다.

<figure style = "width : 700px" class="align-center">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/conv2dkernel.gif" alt="">
  <figcaption>https://stackoverflow.com/questions/54098364/understanding-channel-in-convolution-neural-network-cnn-input-shape-and-output</figcaption>
</figure>

이미지와 같이 커널은 한번에 커널 크기만큼의 이미지 픽셀 값을 얻으며, 이미지의 모든 값을 얻을 때까지 반복합니다.

### Sequential
```python
import tensorflow as tf
import numpy as np

# data
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255, x_test / 255 # rescaling

x_train = x_train[..., np.newaxis]
x_test = x_test[..., np.newaxis]

# build a model (5 layers)
model = tf.keras.Sequential([
		# 1. filter(kernel channel) = 32, kernel = 3, relu, conv2d layer
    tf.keras.layers.Conv2D(32, 3, activation='relu'),
		# 2. filter = 64, kernel = 3, relu, conv2d layer
    tf.keras.layers.Conv2D(64, 3, activation='relu'),
		# 3. flatten layer
    tf.keras.layers.Flatten(),
	  # 4. output = 128 nodes, relu, fully-connected dense layer
    tf.keras.layers.Dense(128, activation='relu'),
		# 5. ouput = class (data), relu, fully-connected dense layer
    tf.keras.layers.Dense(10, activation='softmax')
])

# parameter updates method = adam, loss function = crossentropy
model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])

# adjust model
model.fit(x_train, y_train, epochs = 5)

model.evaluate(x_test, y_test, verbose = 2)
```
### Functional
```python
import tensorflow as tf
import numpy as np

# data
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255, x_test / 255 # rescaling

x_train = x_train[..., np.newaxis]
x_test = x_test[..., np.newaxis]

# build a model (5 layers)
inputs = tf.keras.Input(shape = (28, 28, 1))
x = tf.keras.layers.Conv2D(32, 3, activation = 'relu')(inputs)
x = tf.keras.layers.Conv2D(64, 3, activation = 'relu')(x)
x = tf.keras.layers.Flatten()(x)
x = tf.keras.layers.Dense(128, activation = 'relu')(x)
outputs = tf.keras.layers.Dense(10, activation = 'softmax')(x)

model = tf.keras.Model(inputs = inputs, outputs = outputs)

# compile model
model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])

# adjust model
model.fit(x_train, y_train, epochs = 5)

model.evaluate(x_test, y_test, verbose = 2)
```
### Subclassing
```python
import tensorflow as tf
import numpy as np

# data
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255, x_test / 255 # rescaling

x_train = x_train[..., np.newaxis]
x_test = x_test[..., np.newaxis]

# build a model
class MNISTModel(tf.keras.Model):
    def __init__(self):
        super(MNISTModel, self).__init__()
        self.Conv2D1 = tf.keras.layers.Conv2D(32, 3, activation = 'relu')
        self.Conv2D2 = tf.keras.layers.Conv2D(64, 3, activation = 'relu')
        self.Flatten = tf.keras.layers.Flatten()
        self.Dense1 = tf.keras.layers.Dense(128, activation = 'relu')
        self.Dense2 = tf.keras.layers.Dense(10, activation = 'softmax')

    def call(self, x):
        x = self.Conv2D1(x)
        x = self.Conv2D2(x)
        x = self.Flatten(x)
        x = self.Dense1(x)
        x = self.Dense2(x)

        return x

model = MNISTModel()

# compile model
model.compile(optimizer = 'adam', loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])

# adjust model
model.fit(x_train, y_train, epochs = 5)

model.evaluate(x_test, y_test, verbose = 2)
```

## 실습 2. CIFAR - 100

### Sequential
### Functional
### Subclassing
